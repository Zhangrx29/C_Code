#define _CRT_SECURE_NO_WARNINGS 1//scanf
#include <stdio.h>//printf

int my_strlen(char* str)
{
	char* str_least = str;
	while (*str != '\0' )
	{
		str++;
	}
	return str - str_least;
}

int main()
{
//野指针
	
	//野指针成因1 - 指针未初始化
	//int* p;	//局部变量不初始化的话,默认是随机值
	//*p = 20;	//你不知道那个随机值的地址是不是你的,能否访问, 直接解引用赋值,就造成非法访问内存了
	
	//野指针成因2 - 指针越界访问
	int arr[10] = { 0 };
	int* pa = arr;
	int i; 
	for (i = 0; i <= 10; i++)
	{
		*pa = 1;
		pa++;//数组只有10个元素,这里让指针访问11个元素,多出来的4个指针地址(int) 不属于这个指针变量指向的数组, 会造成越界访问
	}

	//野指针成因3 - 指针指向的空间释放
	//指针指向的空间释放后,再访问原先的地址,也许可以访问,但是这个地址指向的值已经释放,再访问就是非法访问了


//如何避免野指针 
	//	1.指针初始化 - 不知道当前指针变量应该初始化为什么地址时, 直接初始化为NULL(空指针)
	int* p = NULL;
	//当明确知道初始化的值
	int a = 10;
	int* pb = &a;

	//	2.小心指针越界
	//C语言本身是不会检查数据的越界行为,所以这时候要自己检查

	//	3.指针指向空间释放即时的置为NULL - 当指针指向的空间释放后,即时将它置成NULL

	//	4.指针使用之前检查有效性
	//*p = 20;	 //此时*p解引用赋值为20会报错,因为此时p的地址是NULL 
	//C语言本身是不会检查数据的越界行为,这时可以自己加一个判断
	if (p != NULL)
	{
		*p = 20;
	}


//指针运算
	//	1.指针+-整数
	//	2.指针的关系运算
	int arr2[5];
	int* pc = NULL;
	for (pc = arr2; pc <= arr2[5-1];)//	2. 指针的关系运算
	{
		*pc = 2;
		pc++;//	1. 指针+整数
	}

	//	3.指针-指针  指针+指针? 无意义
	int arr3[5] = { 2,4,6,8,0 };
	printf("%d\n", &arr3[4] - &arr3[0]);//	4
	//	指针-指针 得到的是两个指针之间的元素个数
	
	char c[5];
	printf("%d\n", &arr3[4] - &c[0]);//不知道怎么算,导致问题
	//	指针和指针相减的前提是 - 两个指针指向同一块空间

	//指针-指针的应用
	int nums = my_strlen("abcde");//在第四行定义的函数
	printf("nums = %d\n", nums);

	return 0;
}
