#define _CRT_SECURE_NO_WARNINGS 1//scanf
#include <stdio.h>//printf
//创建结构体
struct People
{
	char name[10];
	int id;
	int age;
	char gender[6];
};
int main()
{
	//结构成员访问操作符
	//	.	访问 - 结构体变量名.成员名
	//	->		指针指向
		//初始化结构体
		struct People a = { "张翔", 114514, 16, "man" };
		//	.的访问
		printf("name is %s\nid is %d\nage is %d\ngender is %s", a.name, a.id, a.age, a.gender);

		//	->指针访问
		printf("\n指针访问\n");
		struct People* pa = &a;
		printf("name is %s\nid is %d\nage is %d\ngender is %s", pa -> name, pa -> id, pa->age, pa->gender);

	//表达式求值 - 表达式求值的顺序一部分是由操作符的优先级和结合性决定		
	// 同样,有些表达式的操作数在求值的过程中可能需要转换为其他类型
		//隐式类型转换
			//整型提升 - 不足4字节,参与运算就整型提升
				//C的整形算术运算总是至少以缺省整型类型的精度来进行的, 为了获取这个精度,表达式中的字符和短整型操作数在使用之前被转换为普通整型,这种转换被称为整型提升
				//计算时char or short 内存不满4个字节,所以会进行整型提升(提升到4字节,32比特位), 整型提升是补充二进制的符号位

	//整型提升计算原理
	char x = 8;
	//内存中存储的是补码,(正整数的 原码 反码 补码一样), 所以负整数需要进行转换
	//char为1字节,8比特位, 这里是 0000 1000
	//然后整型提升为4字节 0000 0000 0000 0000 0000 0000 0000 1000  (补充二进制的符号位)
	char y = 126;
	//	0111 1110
	//整型提升 -					0000 0000 0000 0000 0000 0000 0111 1110 
	char z = x + y;
	//相加 -						0000 0000 0000 0000 0000 0000 1000 0110 
	// z只能放8个比特位 结果为1000 0110
	printf("\nChar z = %d\n", z);//这里是%d打印整形4字节 , 而z是1个字节,不够,所以进行整型提升 
	//整型提升 -					1111 1111 1111 1111 1111 1111 1000 0110
	//补码转原码(-1后反转, 符号位不变)	1111 1111 1111 1111 1111 1111 1000 0101 
	//(转换后 - 结果)			1000 0000 0000 0000 0000 0000 0111 1010
	// -122
	


	return 0;
}